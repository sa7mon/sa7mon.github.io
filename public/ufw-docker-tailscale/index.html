<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>UFW, Docker, and Tailscale: Lessons Learned - Dan [the] Salmon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Dan Salmon">
  <meta name="keywords" content="">
  <link rel="canonical" href="https://danthesalmon.com/ufw-docker-tailscale/">


  
  
  
  
  
  


  <meta property="og:image" content="https://danthesalmon.com/../images/me.png" />
  <meta property="og:site_name" content="danthesalmon.com" />
  <meta property="og:type" content="object" />
  <meta property="og:title" content="UFW, Docker, and Tailscale: Lessons Learned" />
  <meta property="og:url" content="https://danthesalmon.com/ufw-docker-tailscale/" />
  <meta property="og:description" content="Learning new tech is hard." />


  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="https://danthesalmon.com/css/combined-min.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="https://danthesalmon.com" class="site-title">Dan [the] Salmon</a>
      <nav class="site-nav right">
      <a href="https://danthesalmon.com/about/">About</a>
<a href="https://danthesalmon.com/tags/">Tags</a>
<a href="https://danthesalmon.com/search/">Search</a>
<a href="https://danthesalmon.com/contact/">Contact</a>
</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">UFW, Docker, and Tailscale: Lessons Learned</h1>
       
        <span class="post-meta">Jun 24, 2022</span><br>
        
      </div>

      <div id="sponsor">
	
	
		<a href="http://join.robinhood.com/dans135" target="_blank" rel="noopener">ðŸ’¸ Join Robinhood today and get a free stock! ðŸ’¸</a>
	
	<br>
	<span class="about"><a href="https://danthesalmon.com/sponsors">About these ads</a></span>
</div>

      <article class="post-content">
      <p>This is a cautionary tale about something that happened to me in the past few weeks. I&rsquo;m posting it because I believe a lot can be learned by professionals (and others such as me) posting their security fails and problem-solving processes.</p>
<p>I have a server at Hetzner for a personal project. It&rsquo;s running Ubuntu with Docker and there are a few Docker containers running, Postgres and RabbitMQ among them. Last week I logged into the server to do some work and noticed it was running a bit slow. When I opened <code>htop</code> I was shocked to find that this 4-core 8GB server was running at nearly 100% utilization. This was surprising because the average load created by my tinkering is about 30%. It was also surprising because I didn&rsquo;t recognize the name of the process eating up all the resources.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>root@scan01:/$ ps aux
</span></span><span style="display:flex;"><span>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span style="display:flex;"><span>postgres       1  0.0  0.2 213260 22636 ?        Ss   13:14   0:02 postgres
</span></span><span style="display:flex;"><span>postgres      28  0.0  0.1 213396  8136 ?        Ss   13:14   0:00 postgres: checkpointer
</span></span><span style="display:flex;"><span>postgres      29  0.0  0.0 213260  5476 ?        Ss   13:14   0:00 postgres: background writer
</span></span><span style="display:flex;"><span>postgres      30  0.0  0.1 213260  9664 ?        Ss   13:14   0:00 postgres: walwriter
</span></span><span style="display:flex;"><span>postgres      31  0.0  0.1 213928  8388 ?        Ss   13:14   0:00 postgres: autovacuum launcher
</span></span><span style="display:flex;"><span>postgres      32  0.0  0.0  67988  5560 ?        Ss   13:14   0:00 postgres: stats collector
</span></span><span style="display:flex;"><span>postgres      33  0.0  0.0 213696  6424 ?        Ss   13:14   0:00 postgres: logical replication launcher
</span></span><span style="display:flex;"><span>postgres    3143  0.0  0.0   2412   104 ?        Ssl  14:12   0:00 TvsFUlqh
</span></span><span style="display:flex;"><span>postgres    3704  0.4  0.0  20544   580 ?        Ssl  14:18   0:27 tracepath
</span></span><span style="display:flex;"><span>postgres    4508  391 30.2 2443568 2403820 ?     Ssl  14:25 409:05 4tn6Cn6Q
</span></span><span style="display:flex;"><span>root       10975  0.0  0.0   7092  3740 pts/0    Ss   16:05   0:00 bash
</span></span><span style="display:flex;"><span>root       11606  0.0  0.0   9692  3216 pts/0    R+   16:09   0:00 ps aux
</span></span></code></pre></div><p>Digging into it a bit, I found that this process was not running on the Ubuntu host, but rather in the Postgres container. As a security researcher, I will admit I was excited by this. A real-life intrusion - on my box! And it&rsquo;s not even (intentionally) a honeypot! I really wanted to know a few things about this hack:</p>
<ul>
<li>How did they get in</li>
<li>What were they doing with my poor server</li>
</ul>
<p>I knew from the little I&rsquo;ve read about the DFIR process that I shouldn&rsquo;t just nuke this container immediately but should capture as much evidence as I can first. Hopefully there are some clues in there about what&rsquo;s going on. I had no idea the best way to go about this (I&rsquo;m a pentester by trade) - the only forensics training I&rsquo;ve had was about dissecting full system and memory dumps with Autopsy and Volatility. I didn&rsquo;t know how to actually capture these dumps and I also wanted to minimize the time my box was being used for malicious purposes. So after googling around a little and consulting my friend <a href="https://twitter.com/C4pr1c0">C4pr1c0</a> who does a lot of research into Docker botnets, I did the following:</p>
<ul>
<li>Saved an image of the container with <code>docker export</code></li>
<li>Saved a diff of the container with <code>docker diff</code></li>
<li>Captured traffic on both the <code>eth0</code> and <code>tailscale0</code> interfaces with <code>tcpdump</code></li>
<li>Tried to find the binary that was running with <code>find</code> to no avail</li>
</ul>
<p>It seemed like the malware had either deleted any files it had dropped after it ran, or had never hit the disk in the first place</p>
<pre tabindex="0"><code>root@scan01:~# ls -alh /proc/4508/exe
lrwxrwxrwx 1 systemd-coredump systemd-coredump 0 May 31 15:43 /proc/4508/exe -&gt; &#39;/var/lib/postgresql/data/08d28c02e5a9bfed60e333377fc8189d (deleted)&#39;
</code></pre><p>Looking through the postgres container logs, there were hundreds of authentication attempt logs going back a few days. Scrolling past those, I then found a huge query that had failed to run:</p>
<p><img src="../images/postgres_payload.png" alt="Postgres Payload"></p>
<p>I immediately recognized the text blob as base64 text due to the equal sign padding at the end - then I realized that it gets piped to <code>base64 --decode</code>. Also a pretty clear indicator. Decoding this yields the following shell script: <a href="https://gist.github.com/sa7mon/f5f36237b44e984bf311bc50949513c6">https://gist.github.com/sa7mon/f5f36237b44e984bf311bc50949513c6</a></p>
<p>In short, the attacker utilized the Postgres <code>COPY</code> command with the <code>FROM COMMAND</code> argument to call shell commands in the container as the <code>postgres</code> user. The script pulls down some required tools like a pre-compiled curl binary then uses it to download 3 payloads hosted on a Tor server, but accessed via Tor2web on the clearnet. Unfortunately, by the time I had gotten this far the payload URLs returned 404 errors so I didn&rsquo;t get any further.</p>
<p>In the tcpdump logs, I could see a ton of SSH traffic to tons of IP addresses. My guess is the attacker was using my machine to either just scan and fingerprint SSH servers or to actively bruteforce them.</p>
<p>After my evidence gathering was complete, I killed the container and started looking at how the attacker may have gotten in. The Postgres container that had been compromised was part of a <code>docker-compose</code> config that brought up the service with port 5432 mapped to the host and just used the default credentials. This seemed fine because only the localhost can access Docker mapped ports.</p>
<p>Now is probably a good time to mention that this box also has UFW and Tailscale installed. The UFW rules I had configured looked like this:</p>
<pre tabindex="0"><code>$ sudo ufw status verbose
Status: active
Logging: on (low)
Default: deny (incoming), allow (outgoing), deny (routed)
New profiles: skip

To                         Action      From
--                         ------      ----
Anywhere on tailscale0     ALLOW IN    Anywhere
41641/udp                  ALLOW IN    Anywhere
22/tcp                     ALLOW IN    Anywhere
Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)
41641/udp (v6)             ALLOW IN    Anywhere (v6)
22/tcp (v6)                ALLOW IN    Anywhere (v6)
</code></pre><p>I had followed Tailscale&rsquo;s <a href="https://tailscale.com/kb/1077/secure-server-ubuntu-18-04/">guide</a> on setting up proper UFW rules. It seemed like my rules were good so how did the bad actor access my Postgres port? I started thinking about the firewall rules - specifically the <code>on tailscale0</code> bit. I guess it was just an assumption on my part that if I allowed traffic to that interface, Tailscale would block traffic from devices that aren&rsquo;t part of my account. Being a person of science (allegedly, according to my degree), I know assumptions are <strong>not</strong> scientific so I needed to test that theory. I <code>nmap</code>&rsquo;d the <code>100.97.0.0/16</code> range which is a CG-NAT subnet Tailscale uses. Sure enough, I was able to see hosts up that didn&rsquo;t belong to me and I could even see open ports on some of them.</p>
<p><em>Side note</em>: I&rsquo;m probably misunderstanding something, but this seems to directly contradict <a href="https://tailscale.com/kb/1136/tailnet/">their docs</a> about how Tailnets work.</p>
<p>Right, so contrary to what I thought, any UFW rules which allow traffic on the <code>tailscale0</code> interface will let any Tailscale user hit that port. This was easy enough to fix: I just deleted that rule and then planned on adding one in the future to only allow traffic from my laptop&rsquo;s Tailscale IP (which are static no matter where you are - one of the truly awesome things about the service). I brought the container back up, watched it for a few minutes to make sure no one broke in, and called it a day.</p>
<p>4-5 days later I received an email from Hetzner with the subject <code>Abuse Message [AbuseID:XXXXX]: NetscanOutLevel: Netscan detected from x.x.x.x</code> (my Hetzner public IP). In the email it said that my box was doing tons of malicious scanning of machines on port 8081 and that if I didn&rsquo;t knock it off, they would block network access from my server. Ugh, again?</p>
<p>I quickly connected to the box and immediately killed the container this time. No time to grab evidence because Hetzner is mad at me and I don&rsquo;t want to get banned from their service. So how did the container get compromised again?</p>
<p>Time to take another look at my UFW rules. I <code>nmap</code>&rsquo;d my Hetzner public IP to verify that only port 22 was open, but saw that my RabbitMQ port (the only other container running) was connectable from the internet.</p>
<pre tabindex="0"><code>$ nmap -Pn -sV -p 15672 100.94.26.5
Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-10 17:50 CDT
Discovered open port 15672/tcp on 100.94.26.5
Scanned at 2022-06-10 17:50:36 CDT for 11s

PORT      STATE SERVICE REASON  VERSION
15672/tcp open  http    syn-ack Cowboy httpd
</code></pre><p>wtf?</p>
<p>(If you are more knowledgeable with Docker than I am, which is likely, you probably already know what&rsquo;s going on.)</p>
<p>After searching for &ldquo;ufw + docker&rdquo; I quickly found a lot of people asking the same question I was. I soon learned that by default Docker manipulates <code>iptables</code> to control network traffic between the host and containers. UFW also manipulates <code>iptables</code> rules (it&rsquo;s essentially a frontend for <code>iptables</code>). It turns out Docker and UFW don&rsquo;t play well together for this reason.</p>
<p>There were actually 2 problems with my setup at this point - none of the UFW rules were properly applying and the Docker container ports which were mapped to the host were being bound to -all- interfaces. This is default Docker behavior I was unaware of; if your box is not behind a firewall or at least NAT&rsquo;d behind a router, that port is now open to the internet.</p>
<p>The fix for the firewall rules problem is actually pretty simple and Docker <a href="https://docs.docker.com/network/iptables/">has documentation</a> around it: just edit <code>/etc/docker/daemon.json</code> to include <code>{&quot;iptables&quot;: false}</code> and restart Docker. I did this, but for some reason Docker threw an error after I made the change and did a <code>service docker restart</code>. <code>journalctl</code> was no help, but the daemon started up fine with <code>dockerd -debug</code> so I ended up just restarting the server. After it came back up, Docker was running perfectly with the <code>iptables</code> changes intact.</p>
<p>After a quick <code>nmap</code> I was able to confirm the mapped ports were not accessible outside the box. I ended up not mapping any container ports to the host and just let the containers communicate directly, but Docker does allow you to bind a mapped container port to a single interface with <code>-p IP:host_port:container_port</code>.</p>
<p><strong>Lessons learned:</strong></p>
<ul>
<li>While Tailscale does indeed work like magic, it does not automatically block traffic from other Tailscale users. Configuring traffic to only come from the <code>tailscale0</code> interface does not limit traffic to only your devices - any Tailscale user can hit it.</li>
<li>Hetzner is a great cloud provider and I&rsquo;m glad they&rsquo;re proactive about kicking malicious users off their platform. If you want to try them out, you can use <a href="https://hetzner.cloud/?ref=V9TzL9Jf56Ge">this referral link</a> for â‚¬20 in cloud credits</li>
<li>Docker and ufw do not play nice together by default</li>
<li>Even if I&rsquo;m just spinning up a test container, I should probably change default creds</li>
<li>If a container doesn&rsquo;t need its ports mapped to the docker host, don&rsquo;t map them. Just let the containers communicate with each other directly.</li>
<li>If I do map ports to the host, I need to pay attention to which interface that port binds to.</li>
</ul>

      </article>

      <p class="post-meta">Tags:&nbsp;
        
            
            <a href="https://danthesalmon.com/tags/ufw">ufw</a>
        
            ,&nbsp;
            <a href="https://danthesalmon.com/tags/tailscale">tailscale</a>
        
            ,&nbsp;
            <a href="https://danthesalmon.com/tags/docker">docker</a>
        
            ,&nbsp;
            <a href="https://danthesalmon.com/tags/security">security</a>
        
      </p>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="https://danthesalmon.com/index.xml"></a>

<a class="fa fa-twitter twitter" href="https://twitter.com/bltjetpack"></a>

</nav>

          <small>
            Copyright &#169; 2022<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/sa7mon/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>

    
    <script src="https://danthesalmon.com/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    

</body>
</html>

