<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Validating JSON Quickly with Go | Dan [the] Salmon</title><link rel=alternate type=application/rss+xml title="Dan [the] Salmon: Posts" href=/posts/index.xml><link rel=alternate type=application/rss+xml title="Dan [the] Salmon: Links" href=/links/index.xml><link rel=me href=https://infosec.exchange/@dan name=Mastodon><link rel=me href=https://github.com/sa7mon name=GitHub><link rel=stylesheet href=/combined.min.a5fe1913713a5e577355cad1fe1240b37249c2f949298b40b20c33e509bdae1e.css integrity="sha256-pf4ZE3E6XldzVcrR/hJAs3JJwvlJKYtAsgwz5Qm9rh4=" crossorigin=anonymous></head><body><header><div class=header-container><a class=brand href=/>Dan [the] Salmon</a><nav><ul><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/links/>Links</a></li><li><a href=/contact/>Contact</a></li></ul></nav></div></header><main class=page><time class=pub-date datetime=2020-10-19T00:00:00+00:00>October 19, 2020</time><h1 class=title>Validating JSON Quickly with Go</h1><div class=tags><a href=/tags/programming/>Programming</a>
<a href=/tags/golang/>Golang</a>
<a href=/tags/go/>Go</a></div><p>I was recently working on a project that involved a large amount of data. I had a dataset of approximately <strong>800 million</strong> records that I wanted to do some analytics on. The dataset was in the form of a single file consisting of JSON objects, one per line.</p><p>In order to do my analytics I wanted to get this data into a SQLite database for easier querying. My plan was to import this gigantic file into a MongoDB instance since the data seemed to come from MongoDB originally and it can quickly parse JSON objects, then copy the data to a SQLite database using CSV as an intermediary if needed.</p><p>My first attempt was to naively use <code>mongoimport</code> on the dataset file. This failed rather quickly due to something I hadn&rsquo;t considered: not all of the lines in the dataset file contained valid JSON. Whoever had created this dataset had mangled the export:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{&#34;_id&#34;:{&#34;$oid&#34;:&#34;af331c12ec52fb31d6bdd78a&#34;},&#34;title&#34;:+Infinity,&#34;date_created&#34;:&#34;&#34;,&#34;state&#34;:&#34;complete&#34;,&#34;last_updated&#34;:&#34;3/19/2009 04:57:02&#34;,&#34;done&#34;:1.0}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{&#34;_id&#34;:{&#34;$oid&#34;:&#34;af331c12ec52fb31d68976f&#34;},&#34;title&#34;:&#34;About&#34;,&#34;date_created&#34;:NaN,&#34;state&#34;:&#34;complete&#34;,&#34;last_updated&#34;:&#34;3/19/2009 04:57:12&#34;,&#34;done&#34;:1.0}
</span></span></code></pre></div><p>Some records included <code>NaN</code> and <code>+Infinity</code> as values in key-value pairs which, because they are unquoted, are not valid JSON values.</p><p>The first thing I did was use GNU <code>split</code> to chop up the dataset file into smaller, more manageable pieces. It was clear that dealing with a <strong>138 GB</strong> flat file was going to be too cumbersome.</p><p>Next, I wrote a very simple Node.js script to read and parse each file line by line and echo the line number of any invalid lines.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>currentLine</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>lineReader</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;readline&#39;</span><span class=p>).</span><span class=nx>createInterface</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>input</span><span class=o>:</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>).</span><span class=nx>createReadStream</span><span class=p>(</span><span class=s1>&#39;sample.bson.json&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=nx>lineReader</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;line&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>line</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>line</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=nx>ex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`Line: </span><span class=si>${</span><span class=nx>currentLine</span><span class=si>}</span><span class=sb>`</span> <span class=o>+</span> <span class=s1>&#39;\n&#39;</span> <span class=o>+</span> <span class=nx>line</span> <span class=o>+</span> <span class=s1>&#39;\n\n&#39;</span> <span class=o>+</span> <span class=nx>ex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>currentLine</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>currentLine</span> <span class=o>%</span> <span class=mi>1000000</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`Parsed </span><span class=si>${</span><span class=nx>currentLine</span><span class=si>}</span><span class=sb> lines`</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>After testing the script on a few &ldquo;known bad&rdquo; lines, I confirmed that it was working correctly. I threw one of the 30M line data files at it, but man was it slow.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>time</span> node validate.js big_01.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real    11m41.919s
</span></span><span class=line><span class=cl>user    11m54.003s
</span></span><span class=line><span class=cl>sys     0m28.124s
</span></span></code></pre></div><p>12 minutes to crank through the 6.4GB file puts the throughput at about 9 MB/s. I should mention that the machine I&rsquo;m testing on is not new by any stretch - it&rsquo;s a dual-core 2010 MacBook Pro with 16GB RAM and the drive this file is on is a 1TB 7200 RPM HDD. That being said, the drive is able to achieve sequential read speeds around 200MB/s according to my very un-scientific testing</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ dd <span class=k>if</span><span class=o>=</span>big_01.json <span class=nv>of</span><span class=o>=</span>/dev/null <span class=nv>bs</span><span class=o>=</span><span class=k>$((</span><span class=m>1024</span> <span class=o>*</span> <span class=m>1024</span><span class=k>))</span>
</span></span><span class=line><span class=cl>6570+1 records in
</span></span><span class=line><span class=cl>6570+1 records out
</span></span><span class=line><span class=cl><span class=m>6889608071</span> bytes transferred in 31.837189 secs <span class=o>(</span><span class=m>216401268</span> bytes/sec<span class=o>)</span>
</span></span></code></pre></div><p>That is to say: disk speed is not the bottleneck with this script. While running the script, I was also watching updates from <code>htop</code> and could see it was consuming about 75% CPU usage, which means one core was almost completely utilized. That&rsquo;s when I remembered that Node is single-threaded. ðŸ¤¦</p><p>This seemed like a good excuse for me to sharpen my Golang skills, which I would say hover around &rsquo;novice&rsquo; currently. After doing some searching, I found an excellent example of what I was trying to do <a href=https://stackoverflow.com/a/22129435>on StackOverflow</a>. Using this as the base, I added file reading logic and came up with the following simple code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;bufio&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;encoding/json&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;flag&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isJSON</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>js</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>js</span><span class=p>)</span> <span class=o>==</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fptr</span> <span class=o>:=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>,</span> <span class=s>&#34;test.txt&#34;</span><span class=p>,</span> <span class=s>&#34;file path to read from&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>uptr</span> <span class=o>:=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>Int</span><span class=p>(</span><span class=s>&#34;update&#34;</span><span class=p>,</span> <span class=mi>1000000</span><span class=p>,</span> <span class=s>&#34;How many lines should be checked before printing an update&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=o>*</span><span class=nx>fptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=nx>bufio</span><span class=p>.</span><span class=nf>NewScanner</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>lineNumber</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>isJSON</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>Text</span><span class=p>())</span> <span class=o>==</span> <span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Error: line %v\n&#34;</span><span class=p>,</span> <span class=nx>lineNumber</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>lineNumber</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>lineNumber</span> <span class=o>%</span> <span class=o>*</span><span class=nx>uptr</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v lines processed\n&#34;</span><span class=p>,</span> <span class=nx>lineNumber</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This seemed to validate JSON accurately, so I compiled and ran it against the same JSON file as before as a benchmark.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>time</span> ./first_try.bin -file big_01.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real    9m30.545s
</span></span></code></pre></div><p>Nice, we&rsquo;ve trimmed off 2 whole minutes! This is a very nice improvement, but I had a feeling we could do even better.</p><p>I looked around for an alternative JSON parsing library and came across <a href=https://github.com/valyala/fastjson>valyala/fastjson</a>. This was very easy to drop into my script - here are the new relevant lines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=nx>bufio</span><span class=p>.</span><span class=nf>NewScanner</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>p</span> <span class=nx>fastjson</span><span class=p>.</span><span class=nx>Parser</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>lineNumber</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>Text</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Error: line %v\n&#34;</span><span class=p>,</span> <span class=nx>lineNumber</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>lineNumber</span><span class=o>++</span>
</span></span></code></pre></div><p>Running against the same file, I was shocked at the new speed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>time</span> ./fastjson.bin -file big_01.json<span class=sb>`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real    1m7.910s
</span></span></code></pre></div><p><strong>The new version completed in just over 1 minute.</strong> That&rsquo;s a speedup of 10x!</p><p>I was incredibly pleased with these results, but wanted to see if I could squeeze any more performance out of Go. I saw in the documentation that the fastjson <code>Parser</code> has a <code>ParseBytes</code> method that takes an array of bytes instead of a string. This is good because if I just pass a byte array from the Scanner to the Parser, I could skip the Scanner <code>.Text()</code> memory allocation.</p><p>The relevant section of the for-loop now looked like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-golang data-lang=golang><span class=line><span class=cl><span class=k>for</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Scan</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>ParseBytes</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Error: line %v\n&#34;</span><span class=p>,</span> <span class=nx>lineNumber</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>This resulted in even better time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>time</span> ./fastjson_bytes.bin -file big_01.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real	0m57.196s
</span></span></code></pre></div><p>Parsing bytes instead of a string improved our time by 15%!</p><p>It was at this point that I started trying to feed the validated dataset chunks into MongoDB, but got a number of &ldquo;invalid JSON&rdquo; type errors. I re-ran the original Node version and compared the output to the output of the latest Go version. The Node version showed dozens of problem files while the Go version showed only 1-2.</p><p>Doing some digging into the problem, it looked like my mistake was in mixing up the term &ldquo;validate&rdquo; with &ldquo;parse&rdquo;. After switching to the <code>fastjson.ValidateBytes()</code> method, the Go version now validated the files properly and the output matched that of the Node version.</p><p>The switch to <code>ValidateBytes()</code> did add about 23 seconds to our overall time, but the most important feature of this tool is that it must validate accurately.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>time</span> ./fastjson_validatebytes.bin -file big_01.json
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>real    1m23.334s
</span></span></code></pre></div><h2 id=lessons-learned>Lessons Learned</h2><p>Performance tuning is fun, but make sure you don&rsquo;t lose sight of your goal.</p><h2 id=further-improvements>Further Improvements</h2><p>I&rsquo;m sure I could have taken this optimization project much further. One idea was to take advantage of Go&rsquo;s multi-threaded ability by reading in large chunks of the file at a time and validating multiple chunks simultaneously by spinning up a thread for each chunk. If you have an example of doing this or have other ideas on how I could have improved this further, please do reach out. My contact info can be found <a href=/contact>here</a>.</p></main></body></html>