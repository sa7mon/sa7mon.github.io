<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>UFW, Docker, and Tailscale: Lessons Learned | Dan [the] Salmon</title><link rel=alternate type=application/rss+xml title="Dan [the] Salmon: Posts" href=/posts/index.xml><link rel=alternate type=application/rss+xml title="Dan [the] Salmon: Links" href=/links/index.xml><link rel=me href=https://infosec.exchange/@dan name=Mastodon><link rel=me href=https://github.com/sa7mon name=GitHub><link rel=stylesheet href=/combined.min.becefdd404be1c72262002823c7115600e4c41cdc0b3ba7ef9621e3d74e2522f.css integrity="sha256-vs791AS+HHImIAKCPHEVYA5MQc3As7p++WIePXTiUi8=" crossorigin=anonymous></head><body><header><div class=header-container><a class=brand href=/>Dan [the] Salmon</a><nav><ul><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/links/>Links</a></li><li><a href=/contact/>Contact</a></li></ul></nav></div></header><main class=page><time class=pub-date datetime=2022-06-24T00:00:00+00:00>June 24, 2022</time><h1 class=title>UFW, Docker, and Tailscale: Lessons Learned</h1><div class=tags><a href=/tags/ufw/>Ufw</a>
<a href=/tags/tailscale/>Tailscale</a>
<a href=/tags/docker/>Docker</a>
<a href=/tags/security/>Security</a></div><blockquote><p><strong>Update 2023-06-21</strong></p><p>This post originally contained some information I now know to be untrue. I got an email yesterday from <a href=https://twitter.com/bradfitz>Brad Fitzpatrick</a> asking me to take a look at the claims I made about Tailscale.</p><p>In my original post, I asserted that any Tailscale user could connect to any other users&rsquo; machines. I believed this after <code>nmap</code>ing a range of CGNAT addresses and seeing up hosts with open ports. In hindsight, I now believe that my ISP at the time (I have since moved) was probably using some of those addresses.</p><p>I can&rsquo;t confirm this because I attempted to replicate my scan results today and was unable. I have updated the post accordingly, but if you wish to read the original post, it is archived <a href=https://web.archive.org/web/20220624194858/https://danthesalmon.com/ufw-docker-tailscale/>here</a>.</p><p>Apologies to the Tailscale team for any grief this caused - I really do love the product!</p></blockquote><hr><p>This is a cautionary tale about something that happened to me in the past few weeks. I&rsquo;m posting it because I believe a lot can be learned by professionals (and others such as me) posting their security fails and problem-solving processes.</p><p>I have a server at Hetzner for a personal project. It&rsquo;s running Ubuntu with Docker and there are a few Docker containers running, Postgres and RabbitMQ among them. Last week I logged into the server to do some work and noticed it was running a bit slow. When I opened <code>htop</code> I was shocked to find that this 4-core 8GB server was running at nearly 100% utilization. This was surprising because the average load created by my tinkering is about 30%. It was also surprising because I didn&rsquo;t recognize the name of the process eating up all the resources.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>root@scan01:/$ ps aux
</span></span></span><span class=line><span class=cl><span class=go>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span></span><span class=line><span class=cl><span class=go>postgres       1  0.0  0.2 213260 22636 ?        Ss   13:14   0:02 postgres
</span></span></span><span class=line><span class=cl><span class=go>postgres      28  0.0  0.1 213396  8136 ?        Ss   13:14   0:00 postgres: checkpointer
</span></span></span><span class=line><span class=cl><span class=go>postgres      29  0.0  0.0 213260  5476 ?        Ss   13:14   0:00 postgres: background writer
</span></span></span><span class=line><span class=cl><span class=go>postgres      30  0.0  0.1 213260  9664 ?        Ss   13:14   0:00 postgres: walwriter
</span></span></span><span class=line><span class=cl><span class=go>postgres      31  0.0  0.1 213928  8388 ?        Ss   13:14   0:00 postgres: autovacuum launcher
</span></span></span><span class=line><span class=cl><span class=go>postgres      32  0.0  0.0  67988  5560 ?        Ss   13:14   0:00 postgres: stats collector
</span></span></span><span class=line><span class=cl><span class=go>postgres      33  0.0  0.0 213696  6424 ?        Ss   13:14   0:00 postgres: logical replication launcher
</span></span></span><span class=line><span class=cl><span class=go>postgres    3143  0.0  0.0   2412   104 ?        Ssl  14:12   0:00 TvsFUlqh
</span></span></span><span class=line><span class=cl><span class=go>postgres    3704  0.4  0.0  20544   580 ?        Ssl  14:18   0:27 tracepath
</span></span></span><span class=line><span class=cl><span class=go>postgres    4508  391 30.2 2443568 2403820 ?     Ssl  14:25 409:05 4tn6Cn6Q
</span></span></span><span class=line><span class=cl><span class=go>root       10975  0.0  0.0   7092  3740 pts/0    Ss   16:05   0:00 bash
</span></span></span><span class=line><span class=cl><span class=go>root       11606  0.0  0.0   9692  3216 pts/0    R+   16:09   0:00 ps aux
</span></span></span></code></pre></div><p>Digging into it a bit, I found that this process was not running on the Ubuntu host, but rather in the Postgres container. As a security researcher, I will admit I was excited by this. A real-life intrusion - on my box! And it&rsquo;s not even (intentionally) a honeypot! I really wanted to know a few things about this hack:</p><ul><li>How did they get in</li><li>What were they doing with my poor server</li></ul><p>I knew from the little I&rsquo;ve read about the DFIR process that I shouldn&rsquo;t just nuke this container immediately but should capture as much evidence as I can first. Hopefully there are some clues in there about what&rsquo;s going on. I had no idea the best way to go about this (I&rsquo;m a pentester by trade) - the only forensics training I&rsquo;ve had was about dissecting full system and memory dumps with Autopsy and Volatility. I didn&rsquo;t know how to actually capture these dumps and I also wanted to minimize the time my box was being used for malicious purposes. So after googling around a little and consulting my friend <a href=https://twitter.com/C4pr1c0>C4pr1c0</a> who does a lot of research into Docker botnets, I did the following:</p><ul><li>Saved an image of the container with <code>docker export</code></li><li>Saved a diff of the container with <code>docker diff</code></li><li>Captured traffic on both the <code>eth0</code> and <code>tailscale0</code> interfaces with <code>tcpdump</code></li><li>Tried to find the binary that was running with <code>find</code> to no avail</li></ul><p>It seemed like the malware had either deleted any files it had dropped after it ran, or had never hit the disk in the first place</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>root</span><span class=err>@</span><span class=n>scan01</span><span class=p>:</span><span class=o>~</span><span class=c1># ls -alh /proc/4508/exe</span>
</span></span><span class=line><span class=cl><span class=n>lrwxrwxrwx</span> <span class=mi>1</span> <span class=n>systemd</span><span class=o>-</span><span class=n>coredump</span> <span class=n>systemd</span><span class=o>-</span><span class=n>coredump</span> <span class=mi>0</span> <span class=n>May</span> <span class=mi>31</span> <span class=mi>15</span><span class=p>:</span><span class=mi>43</span> <span class=o>/</span><span class=n>proc</span><span class=o>/</span><span class=mi>4508</span><span class=o>/</span><span class=n>exe</span> <span class=o>-&gt;</span> <span class=s1>&#39;/var/lib/postgresql/data/08d28c02e5a9bfed60e333377fc8189d (deleted)&#39;</span>
</span></span></code></pre></div><p>Looking through the postgres container logs, there were hundreds of authentication attempt logs going back a few days. Scrolling past those, I then found a huge query that had failed to run:</p><p><img src=../images/postgres_payload.png alt="Postgres Payload"></p><p>I immediately recognized the text blob as base64 text due to the equal sign padding at the end - then I realized that it gets piped to <code>base64 --decode</code>. Also a pretty clear indicator. Decoding this yields the following shell script: <a href=https://gist.github.com/sa7mon/f5f36237b44e984bf311bc50949513c6>https://gist.github.com/sa7mon/f5f36237b44e984bf311bc50949513c6</a></p><p>In short, the attacker utilized the Postgres <code>COPY</code> command with the <code>FROM COMMAND</code> argument to call shell commands in the container as the <code>postgres</code> user. The script pulls down some required tools like a pre-compiled curl binary then uses it to download 3 payloads hosted on a Tor server, but accessed via Tor2web on the clearnet. Unfortunately, by the time I had gotten this far the payload URLs returned 404 errors so I didn&rsquo;t get any further.</p><p>In the tcpdump logs, I could see a ton of SSH traffic to tons of IP addresses. My guess is the attacker was using my machine to either just scan and fingerprint SSH servers or to actively bruteforce them.</p><p>After my evidence gathering was complete, I killed the container and started looking at how the attacker may have gotten in. The Postgres container that had been compromised was part of a <code>docker-compose</code> config that brought up the service with port 5432 mapped to the host and just used the default credentials. This seemed fine because only the localhost can access Docker mapped ports.</p><p>Now is probably a good time to mention that this box also has UFW installed. The UFW rules I had configured looked like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sudo ufw status verbose
</span></span><span class=line><span class=cl>Status: active
</span></span><span class=line><span class=cl>Logging: on (low)
</span></span><span class=line><span class=cl>Default: deny (incoming), allow (outgoing), deny (routed)
</span></span><span class=line><span class=cl>New profiles: skip
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To                         Action      From
</span></span><span class=line><span class=cl>--                         ------      ----
</span></span><span class=line><span class=cl>Anywhere on tailscale0      ALLOW IN    Anywhere
</span></span><span class=line><span class=cl>41641/udp                   ALLOW IN    Anywhere
</span></span><span class=line><span class=cl>22/tcp                      ALLOW IN    Anywhere
</span></span><span class=line><span class=cl>Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)
</span></span><span class=line><span class=cl>41641/udp (v6)              ALLOW IN    Anywhere (v6)
</span></span><span class=line><span class=cl>22/tcp (v6)                 ALLOW IN    Anywhere (v6)
</span></span></code></pre></div><p>The UFW rules seemed fine so I brought the container back up, watched it for a few minutes to make sure no one broke in, and called it a day.</p><p>4-5 days later I received an email from Hetzner with the subject <code>Abuse Message [AbuseID:XXXXX]: NetscanOutLevel: Netscan detected from x.x.x.x</code> (my Hetzner public IP). In the email it said that my box was doing tons of malicious scanning of machines on port 8081 and that if I didn&rsquo;t knock it off, they would block network access from my server. Ugh, again?</p><p>I quickly connected to the box and immediately killed the container this time. No time to grab evidence because Hetzner is mad at me and I don&rsquo;t want to get banned from their service. So how did the container get compromised again?</p><p>Time to take another look at my UFW rules. I <code>nmap</code>&rsquo;d my Hetzner public IP to verify that only port 22 was open, but saw that my RabbitMQ port (the only other container running) was connectable from the internet.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nmap -Pn -sV -p 15672 100.94.26.5
</span></span><span class=line><span class=cl>Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-10 17:50 CDT
</span></span><span class=line><span class=cl>Discovered open port 15672/tcp on 100.94.26.5
</span></span><span class=line><span class=cl>Scanned at 2022-06-10 17:50:36 CDT for 11s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>PORT      STATE SERVICE REASON  VERSION
</span></span><span class=line><span class=cl>15672/tcp open  http    syn-ack Cowboy httpd
</span></span></code></pre></div><p>wtf?</p><p>(If you are more knowledgeable with Docker than I am, which is likely, you probably already know what&rsquo;s going on.)</p><p>After searching for &ldquo;ufw + docker&rdquo; I quickly found a lot of people asking the same question I was. I soon learned that by default Docker manipulates <code>iptables</code> to control network traffic between the host and containers. UFW also manipulates <code>iptables</code> rules (it&rsquo;s essentially a frontend for <code>iptables</code>). It turns out Docker and UFW don&rsquo;t play well together for this reason.</p><p>There were actually 2 problems with my setup at this point - none of the UFW rules were properly applying and the Docker container ports which were mapped to the host were being bound to -all- interfaces. This is default Docker behavior I was unaware of; if your box is not behind a firewall or at least NAT&rsquo;d behind a router, that port is now open to the internet.</p><p>The fix for the firewall rules problem is actually pretty simple and Docker <a href=https://docs.docker.com/network/iptables/>has documentation</a> around it: just edit <code>/etc/docker/daemon.json</code> to include <code>{"iptables": false}</code> and restart Docker. I did this, but for some reason Docker threw an error after I made the change and did a <code>service docker restart</code>. <code>journalctl</code> was no help, but the daemon started up fine with <code>dockerd -debug</code> so I ended up just restarting the server. After it came back up, Docker was running perfectly with the <code>iptables</code> changes intact.</p><p>After a quick <code>nmap</code> I was able to confirm the mapped ports were not accessible outside the box. I ended up not mapping any container ports to the host and just let the containers communicate directly, but Docker does allow you to bind a mapped container port to a single interface with <code>-p IP:host_port:container_port</code>.</p><p><strong>Lessons learned:</strong></p><ul><li>Hetzner is a great cloud provider and I&rsquo;m glad they&rsquo;re proactive about kicking malicious users off their platform. If you want to try them out, you can use <a href="https://hetzner.cloud/?ref=V9TzL9Jf56Ge">this referral link</a> for â‚¬20 in cloud credits</li><li>Docker and ufw do not play nice together by default</li><li>Even if I&rsquo;m just spinning up a test container, I should probably change default creds</li><li>If a container doesn&rsquo;t need its ports mapped to the docker host, don&rsquo;t map them. Just let the containers communicate with each other directly.</li><li>If I do map ports to the host, I need to pay attention to which interface that port binds to.</li></ul></main></body></html>